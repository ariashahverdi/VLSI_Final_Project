#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>
#include<math.h>
#include"Floorplanning/SA_helper.h"
#include"HotSpot-5.02/hotspot.h"

void main(int argc , char* argv[])
{
	printf("input file : %s\n",argv[1]);

	int module_count=0;
	float lambda = 0;
	float total_size = 0;
	struct module_dim **module_array;
	struct module_dim **module_array_temp;
	struct module_dim *temp_module;
	struct module_dim *free_module;
	struct module *temp_modules;
	int i;
	int *polish_exp;
	int verticle, horizontal;
    unsigned int init_temp = 100000;
	struct cost cost;
	struct cost cost_new;
	int *polish_exp_new;
	float delta_area;
	int random;
	double param_exp;
	double min_temp = 370;
	int flp_ok;

	//Calling Hotspot
	char *argv_hotspot[7]={
        "./hotspot",
		"-c",
		"../HotSpot-5.02/hotspot.config",
        "-f",
        "../data/ev6.flp",
        "-p",
        "../data/gcc.ptrace"};
    float cur_temp;

	/*pseudo-random number generator is initialized using time feed*/
	srand( (unsigned)time( NULL ) );

	/*design file parser*/
	module_count = parse_design(argv[1], &module_array, &lambda, &total_size);

	/*vertical and horizontal section identify with number*/
	verticle = module_count + 1;
	horizontal = module_count + 2;

	/*random polish expression generator*/
	//polish_exp = getRandom(module_count);
	polish_exp = init_polish(module_count);
    printf("size: %d, lambda: %f\n",module_count,lambda);
    cost.area = 10*total_size;

    /*performing sizing slicing on floorplan generated by polish expression*/
	//cost = sizing_slicing(module_array, polish_exp,module_count);

    int flag = 1;
	int iter = 80;
	int cnt = 0;
	int cnt_fail = 0;
	float fin_lambda;
	float my_area;

#ifdef PRINT
	iter = 100;
	init_temp = 3;
#endif

	/* SA algorithm Starts */
	while(init_temp > 0 && flag){

		for(i=0; i<iter; i++){

#ifdef DEBUG
			printf("** 1 **\n");
#endif

#ifdef PRINT
			printf("\n\n**** Next Iteration ****\n");
#endif

		//polish_exp_new = getRandom(module_count);

#ifdef PRINT
			int c;
			print_polish(module_count, polish_exp);
			save_design_ev6(module_count, cost, module_array,polish_exp);
            my_area = get_area(module_count, cost, module_array,polish_exp);
            printf("area before : < %f >\n", my_area);
            printf( "Enter Something, Not That We Care Tho :P\n");
            c = getchar( );
#endif
#ifdef DEBUG
			printf("** 2 **\n");
#endif

			polish_exp_new = smart_move(module_count, polish_exp);
            //polish_exp = polish_exp_new;
			cost_new.area = get_area(module_count, cost, module_array,polish_exp_new);
			//polish_exp_new = getRandom(module_count);

#ifdef DEBUG
			printf("** 3 **\n");
#endif
#ifdef PRINT
            print_polish(module_count, polish_exp_new);
            save_design_ev7(module_count, cost, module_array,polish_exp_new);
            my_area = get_area(module_count, cost, module_array,polish_exp_new);
            printf("area after : < %f >\n", my_area);
            printf( "Enter Something, Not That We Care Tho :P\n");
            c = getchar( );

#endif

/*
#ifdef DEBUG
			printf("** 4 **\n");
#endif

		//cost_new = sizing_slicing(module_array, polish_exp_new,module_count);

#ifdef DEBUG
			printf("** 5 **\n");
#endif
             */

		delta_area = cost_new.area - cost.area;
        fin_lambda = (cost_new.area-total_size)/total_size;
#ifdef PROGRESS
            printf("delta area : %f\n",delta_area);
            printf("lambda (always): %f\n",fin_lambda);
#endif
		// generates random values between 0.1 and 0.9
		random = (rand() % 100);

		// Acceptance probability calculation
		param_exp = (delta_area/init_temp);

		// If new cost is small
		if(delta_area < 0){
			//free(polish_exp);
#ifdef PROGRESS
            fin_lambda = (cost_new.area-total_size)/total_size;
			printf("lambda (improve): %f\n",fin_lambda);
#endif
			polish_exp = polish_exp_new;
			cost.area = cost_new.area;
		}
             
		//Accept with probability
		else if(random > 95/*exp(-(param_exp))*/){
			//free(polish_exp);
#ifdef PROGRESS
            printf("Took a wrong move\n");
#endif
            polish_exp = polish_exp_new;
			cost.area = cost_new.area;
		}

		//free(polish_exp_new);
 
            fin_lambda = (cost_new.area-total_size)/total_size;
            ///*
            if(fin_lambda<lambda && fin_lambda > 0) {
                printf("\nFinal Lambda = %f", fin_lambda);
                i = i;//iter+1 to terminate
            }
            // */
            
		}
		init_temp--;
    }

	/* SA algorith finish */
	//printf("\ncost after SA\n");
	printf("\ncost.area = %f\n", cost.area);
	printf("\nFinal Lambda = %f", fin_lambda);

	temp_modules = cost.final_modules;

	/*
	printf("\nfinal modules\n");
	for(i=0; i<module_count; i++){
		printf("(%d, %f)\t", temp_modules[i].module, temp_modules[i].size);
	}
	*/
	printf("\n");
    
	/*generates output design file */
	cur_temp = get_temp(7, argv_hotspot);
    printf("\nMaximum Temperature: %f\n", cur_temp);

	/*free allocated dynamic memory*/
	module_array_temp = module_array;
	for(i=0; i<module_count; i++){
		temp_module = module_array_temp[i];
		while(temp_module != NULL){
			free_module = temp_module;
			temp_module = temp_module->next;
			free(free_module);
		}
	}

	free(module_array);
}

