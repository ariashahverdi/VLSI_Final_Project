#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>
#include<math.h>
#include"Floorplanning/SA_helper.h"
#include"HotSpot-5.02/hotspot.h"

void main(int argc , char* argv[])
{
	printf("input file : %s\n",argv[1]);

	int module_count=0;
	float lambda = 0;
	float total_size = 0;
	struct module_dim **module_array;
	struct module_dim **module_array_temp;
	struct module_dim *temp_module;
	struct module_dim *free_module;
	struct module *temp_modules;
	int i;
	int *polish_exp;
	int verticle, horizontal;
    unsigned int init_temp = 1000000;
	struct cost cost;
	struct cost cost_new;
	int *polish_exp_new;
	float delta_area;
	int random;
	double param_exp;
	double min_temp = 370;
	int flp_ok;

	//Calling Hotspot
	char *argv_hotspot[7]={
        "./hotspot",
		"-c",
		"../HotSpot-5.02/hotspot.config",
        "-f",
        "../data/ev6.flp",
        "-p",
        "../data/gcc.ptrace"};
    float cur_temp;

	/*pseudo-random number generator is initialized using time feed*/
	srand( (unsigned)time( NULL ) );

	/*design file parser*/
	module_count = parse_design(argv[1], &module_array, &lambda, &total_size);

	/*vertical and horizontal section identify with number*/
	verticle = module_count + 1;
	horizontal = module_count + 2;

	/*random polish expression generator*/
	polish_exp = getRandom(module_count);
    printf("size: %d, lambda: %f\n",module_count,lambda);
	/*for(i=0;i<(2*module_count)-1;i++){
		printf("%d\n",polish_exp[i]);
	}*/

    /*performing sizing slicing on floorplan generated by polish expression*/
	cost = sizing_slicing(module_array, polish_exp,module_count);

	int iter = 80;
	int cnt = 0;
	int cnt_fail = 0;

#ifdef PRINT
	iter = 10;
	init_temp = 1;
#endif

	/* SA algorithm Starts */
	while(init_temp > 0){

		for(i=0; i<iter; i++){

#ifdef PRINT
			printf("\n\n**** Next Iteration ****\n");
#endif


		//polish_exp_new = getRandom(module_count);

#ifdef PRINT
			int c;
			print_polish(module_count, polish_exp);
			optimal_design(module_count, cost, module_array,polish_exp);
			printf( "Enter a Something, Not that we care tho :P");
			c = getchar( );
#endif
		polish_exp_new = smart_move(module_count, polish_exp);
#ifdef PRINT
		print_polish(module_count, polish_exp_new);
		optimal_design2(module_count, cost, module_array,polish_exp_new);
		printf( "Enter a Something, Not that we care tho :P");
		c = getchar( );
#endif

		if(cnt_fail > 100000){
#ifdef PROGRESS
			printf("Random Move\n");
#endif
			polish_exp_new = getRandom(module_count);
			cnt_fail = 0;
		}

		cost_new = sizing_slicing(module_array, polish_exp_new,module_count);
		delta_area = cost_new.area - cost.area;

		float fin_lambda = (cost.area-total_size)/total_size;


		cnt++;
		if(cnt==10000){
#ifdef PROGRESS
			printf("size: %f, lambda: %f\n",cost.area, fin_lambda);
#endif
			optimal_design(module_count, cost, module_array,polish_exp_new);
			cur_temp = get_temp(7, argv_hotspot);
#ifdef PRINT
			printf("Maximum Temperature: %f\n\n", cur_temp);
#endif
			cnt = 0;
		}

		/* generates random values between 0.1 and 0.9*/
		random = (rand() % 9) / 10 ;

		/* Acceptance probability calculation */
		param_exp = (delta_area/init_temp);

		/*If new cost is small */
		if(delta_area < 0){
			//free(polish_exp);
			polish_exp = polish_exp_new;
			cost = cost_new;
		}
		/*Accept with probability*/
		else if(random > exp(-(param_exp))){
			//free(polish_exp);
			polish_exp = polish_exp_new;
			cost = cost_new;
		}
		else{
			cnt_fail++;
		}

		//free(polish_exp_new);
		}
		init_temp--;
    }

	/* SA algorith finish */
	//printf("\ncost after SA\n");
	printf("\ncost.area = %f\n", cost.area);
	float fin_lambda = (cost.area-total_size)/total_size;
	printf("\nFinal Lambda = %f", fin_lambda);

	temp_modules = cost.final_modules;

	/*
	printf("\nfinal modules\n");
	for(i=0; i<module_count; i++){
		printf("(%d, %f)\t", temp_modules[i].module, temp_modules[i].size);
	}
	*/
	printf("\n");
	/*generates output design file */
	//flp_ok = optimal_design(module_count, cost, module_array,polish_exp);
	//if(flp_ok) cur_temp = get_temp(5, argv_hotspot);
    printf("\nMaximum Temperature: %f\n", cur_temp);

	/*free allocated dynamic memory*/
	module_array_temp = module_array;
	for(i=0; i<module_count; i++){
		temp_module = module_array_temp[i];
		while(temp_module != NULL){
			free_module = temp_module;
			temp_module = temp_module->next;
			free(free_module);
		}
	}

	free(module_array);
}

